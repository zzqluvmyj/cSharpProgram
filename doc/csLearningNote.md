### 目录

- [数据类型](#数据类型)
- [方法](#方法)
- [操作符](#操作符)
- [表达式和语句](#表达式和语句)
- [字段,属性,索引器,常量](#字段,属性,索引器,常量)
- [参数](#传值/输出/引用/具名/可选参数,扩展方法)
- [委托详解](#委托详解)
- [事件详解](#事件详解)
- [什么是类](#什么是类)
- [类的声明与访问级别](#类的声明与访问级别)
- [类的继承](#类的继承)
- [类成员的访问控制](#类成员的访问控制)
- [重写和多态](#重写和多态)
- [**抽象类与开闭原则**](#抽象类与开闭原则)


### 数据类型

- 运行时，堆存储类，栈存储方法。堆很大，栈几M.
- var可以自己推断数据类型
- c#数据类型
  - 引用类型
    - 类
    - 接口
    - 委托
  - 值类型
    - 结构体
      - int
      - long
      - byte 1个字节,无符号
    - 枚举
  - 值类型在栈分配空间,引用类型在堆分配空间.
  - 在堆里声明数据效率低(垃圾收集机制),因此值类型在栈中声明.
  - 值类型变量和引用类型变量都存储在栈.值类型变量直接存储值的初始指针,而引用类型变量空间总是4个字节(32,内存的地址应该是32位的),这个空间存储了实际引用类型实例存储空间的初始指针.
  - 方法内的局部变量声明在栈,类内的变量(全局变量)声明在堆.
  - 类内的变量会自动初始化,而方法内的变量不会自动初始化.C语言会在方法内自动初始化,出现垃圾值,也就是会直接调用原有内存中没有清零的值,出现烫烫烫.
  - 装箱和拆箱
    - **将值类型隐式转换为引用类型是装箱**
    - **将引用类型显式转换为值类型是拆箱.**

---

[目录](#目录)

### 方法

- 方法由函数发展而来。函数在类中定义为方法。方法永远只能在类内。
- 字段是成员变量，方法是成员函数。
- 静态方法
- 构造器 ctor tab tab
- 重载方法 参数三个种类

- 操作符
  - 操作符本质是函数的简记法
  - 操作符不能脱离它相关的数据类型
  - 操作符重载
  - Type类型和typeof操作符
  - default操作符  默认值表达式 
    - c#7.1之前 var s=default(string)
    - c#7.1之后  var s=default;
  - 枚举类型显式赋值，可以赋值字符串等

---

[目录](#目录)

### 操作符

- new
  - 匿名类型
    - var person = new { Name = "Tom" };
    - Console.WriteLine(person.GetType().Name);
  - 初始化器
  - new功能强大,但不能滥用,在一个类中声明其他类的实例会造成**紧耦合**,**依赖注入**解决这个问题
- checked
  - 数值越界的时候默认不会报错
  - 加了checked后可以报错
  - check{}或者()  语句序列或者语句
- delegate 
  - 作为操作符已经弃用,使用lambda代替
- sizeof
  - 数据类型的字节数,只能用于结构体类型或者自定义的结构体类型(此时为不安全代码)
  - 不安全代码要使用unsafe括起来
- ->
  - 指针访问操作符,不安全代码
- ~
  - 二进制按位取反
- (T)x  类型转换
  - 隐式类型转换
    - 不丢失精度的转换
    - 子类向父类转换
    - 装箱
  - 显式类型转换
    - 有可能丢失精度 cast
    - 拆箱
    - Convert类
    - 父类向子类转换
    - Parse ,比如double.Parse("4534"),用于将字符串解析为数值,**要求格式正确** tryParse
    - 显式类型转换背后的秘密,非继承类之间的转换
- await
  - 异步操作,太深入,视频暂时不讲
- 算术运算符
  - 略
  - 类型提升
- 位移操作符
  - 数据在内存中的二进制的数据左移动或者右移动
- 关系操作符
  - 比较数值或者字符或者字符串
  - is as 类型检验操作符
    - 比较时,**只要是派生而来的就可以**,比如儿子的类型也是父亲的类型
    - is检测是否是相同类型后返回真假(是不是)
    - as直接返回转换后的值,不能转换返回null(作为)
- 位操作符
- 条件操作符
  - 短路效应
- ?,Nullable<T>,??
- ?:
- 赋值操作符
  - +=./=,%=,-=,<<=,>>=,*=
  - 从右往左结合

---

[目录](#目录)

### 表达式和语句

- 编程语言的基本组成部分
- 表达式有优先级
- 表达式分类
  - 值
  - 变量
  - 名称空间
  - 类型
  - 方法组
  - 空字面值
  - 异步方法
  - 属性访问
  - 事件访问
  - 索引访问
  - 返回值为空的访问
- 复合表达式
- 语句是高级语言的,运行时翻译为指令.
- 语句分类
  - 标签语句
  - 声明语句
  - 表达式语句
  - 块语句
  - 跳转语句
  - 循环语句
  - try语句
- 避免一个方法里面有多种功能,六大设计原则之一,方便该方法的重用.

---

[目录](#目录)

### 字段,属性,索引器,常量

- 字段也就是成员变量,比如结构体,类的成员.

- 属性就是普通的类的成员,字段是早期的类的成员,无法在修改时判定数据合法性.

- **索引器** 类似于数组的访问,但是是自定义的

- 常量只能用于值类型.

  > 懒得写了,感觉今天有些累,除了索引器,其他都曾经用过.

---

[目录](#目录)

### 传值/输出/引用/具名/可选参数,扩展方法

- 传值参数
  - 值类型
  - 引用类型
- 引用参数 参数前要加ref
- 输出参数  
  - 输出多个参数,为了得到若干的输出的参数
  - 与引用参数相似,不会创建形参的副本
  - 关键字out
  - out为了输出,ref为了改变
- 数组参数
  - 和python类似,能够将多个参数变为一个数组
  - 关键字params
  - 必须只有一个params参数,并且必须是最后一个
- 具名参数
  - 就是给参数写名字,可以不按参数列表的属性写参数
  - 比如  age:20
- 可选参数
  - 有默认值,默认值必须在后面
- 扩展方法
  - 扩展方法必须是共有的,静态的
  - 必需是形参列表中的第一个,被this修饰
  - 必须用静态类一般名为someTypeExtension来统一收纳该类型的扩展方法.
  - 举例:LINQ方法

---

[目录](#目录)

### 委托详解

**委托介绍**

委托是函数指针的升级版.

一切皆地址,变量和函数都是以某个地址为起点的所存储的值或者指令.

直接调用:通过函数名来调用函数

间接调用:通过函数指针来调用函数

java中没有函数指针.

委托是一个类,可以自定义委托

**委托的声明(自定义委托)**

委托与所封装的方法必须类型兼容

委托是类,必须声明在名称空间中,其他类外

**委托的使用**

1. 模板方法
2. 回调方法

委托一旦被滥用后果很严重.

**delegate委托**

比如

```c#
public delegate int Add(int x,int y);
class Program{
    static void Main(stirng[] args){
        Add add=AddNum;
        add(3,7);
    }
    public int AddNum(int x,int y){
        return x+y;
    }
}
```

后面还有一些委托的内容,感觉太难了,而且好像也用不到,懒得听了.

---

[目录](#目录)

### 事件详解

事件模型的5个组成部分

- 事件的拥有者
- 事件成员
- 事件的响应者
- 事件处理器
- 事件订阅

举例:我的闹钟响了我起床

---

[目录](#目录)

### 委托,Lambda,LINQ串讲

委托->lambda->LINQ

委托是特殊的类.

- 声明特殊,用delegate声明,样子和方法类似,声明的形式必须和被包装的方法的方法签名和返回值一致.
- 功能特殊:一般类是现实生活中的建模,委托类型包装着方法,让方法能够间接调用.java必须使用接口来做.

**Func有返回值的委托,Action无返回值委托.**

lambda是匿名表达式,边声明边调用(inline方法).

LINQ将c#翻译为SQL语言,可以查询数据库或者其他.

---

[目录](#目录)

### 什么是类

### 类的声明与访问级别

### 类的继承

### 类成员的访问控制

### 重写和多态

省略,这些应该和java和c++中的差不多,不再赘述.

---

[目录](#目录)

### 抽象类与开闭原则

**抽象类必须用abstract修饰,无法实例化,作为基类让其他类继承,让子类实现抽象类中未实现的内容.**

抽象方法又叫纯虚方法,因为没有方法体.

把稳定的,固定的,确定的成员实现,把没有确定的成员作为抽象方法,让子类去实现.

```
接口和抽象类都是软件工程产物
具体类->抽象类->接口:越来越抽象,内部实现越来越少
抽象类是未完全实现逻辑的类,可以由字段和非public成员,它们代表了具体逻辑.
抽象类为了复用而生:专门用作基类,也具有解耦功能.
封装确定的,开放不确定的,推迟到合适的子类中去实现
接口是完全未实现逻辑的类(纯虚类,只有函数成员,成员全部是public,省略不写)
接口为了解耦而生:高内聚,低耦合,方便单元测试
接口是一个协约,早已为工业生产所熟知(有分工必须有写作,有协作必须有协约)
它们都不能实例化,只能用来声明变量,引用具体的实例.
```

**六大设计原则(猎奇补充),是设计模式之母**

- **单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。** 
- **开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。** 
- **里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。**
- **依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**
  - 依赖注入:**指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象** 
- **接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。**
- **迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。** 

---

[目录](#目录)

### 接口,依赖反转,单元测试

